
#### 可能造成内存泄漏的情况

1. 对象之间的循环引用
2. 老版IE（IE8及以前）里面DOM与对象之间的循环引用
3. 全局变量，使用严格模式可以避免
4. 闭包里暴露的变量
5. 没有清理的定时器

### 垃圾回收

#### 引用计数

对象被引用计数+1，被释放计数-1，为0时就释放内存

bug：循环引用

```javascript
// ie8较早的浏览器,现在浏览器不会出现这个问题
function Fn() {
  var objA = { a: 10 }
  var objB = { b: 10 }
  objA.c = objB
  objB.c = objA
}
```

#### 标记清除

当变量进入环境，标记为进入环境，变量离开环境，标记为离开环境，最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间

**环境** 全局环境、函数作用域？

### V8内存管理

V8 引擎限制内存，防止因为垃圾回收所导致的线程暂停执行的时间过长

V8采用了分代回收的策略，将内存分为两个生代：新生代和老生代

#### 新生代

新生代的堆内存被分为多个Semispace，每个Semispace分为两部分from和to，只有from的空间是使用中的，分配对象空间时，只在from中进行分配，to是闲置的。进行垃圾回收时按照如下步骤进行：

1. 找出from中还在使用的对象，即存活的对象
2. 将这些活着的对象全部复制到to
3. 反转from和to，这时候from中全部是存活对象，to全部是死亡对象
4. 对to进行全部回收

新生代中每次回收会发现存活的是少数，复制的就是少数对象，这样效率更高。如果一个变量在新生代中经过几次复制还活着，那他生命周期可能就比较长，会晋升到老生代。

#### 老生代

是一个连续的结构，老生代垃圾回收有两种方式，标记清除和标记合并。

- 标记清除是标记死亡的对象，直接其空间释放掉。在标记清除方法清除掉死亡对象后，内存空间就变成不连续的了
- 标记合并将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收。
