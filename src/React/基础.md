## react事件

由于fiber机制的特点，生成一个fiber节点时，它对应的dom节点有可能还未挂载，onClick这样的事件处理函数作为fiber节点的prop，也就不能直接被绑定到真实的DOM节点上

如果使用class component，需要处理this指向问题

- 使用bind
- 使用箭头函数

```javascript

<span onclick={this.handleClick.bind(this)}>header<span>   

handleClick=(e)=>{
    console.log(e)
    this.doSomething() 
}
```

**DOM事件**

事件捕获，由上至下（不常用）
到达目标
事件冒泡，由下至上

**react事件**

[文档](https://zhuanlan.zhihu.com/p/25883536)

### 特点

- 统一在Document上绑定事件，（17绑定在根组件上）在冒泡阶段处理事件
- React自身实现了一套模拟事件捕获和冒泡机制
- React有一套自己的合成事件SyntheticEvent
- 使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能

### 对象池（17版本移除）

<https://cloud.tencent.com/developer/article/2115440>

```javascript
// 将一个类池化
var addPoolingTo = function<T>(
  CopyConstructor: Class<T>,
  pooler: Pooler, // 用来获取对象池缓存的对象
): Class<T> & {
  getPooled(): T,
  release(): void,
} {
  // 这里拷贝了一份class
  var NewKlass = (CopyConstructor: any); 
  // 为传入的class挂了一个pool池
  NewKlass.instancePool = [];  
  // 挂了一个获取池子中对象的方法
  NewKlass.getPooled = pooler || DEFAULT_POOLER;  
  if (!NewKlass.poolSize) {
    // 限制池子中最大缓存的对象数量
    NewKlass.poolSize = DEFAULT_POOL_SIZE;  
  } 
  // 挂一个释放对象的方法
  NewKlass.release = standardReleaser; 
  return NewKlass;
};

// 一个参数的Pooler
var oneArgumentPooler = function(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    // 如果缓存池中有对象，就直接拿出来用
    var instance = Klass.instancePool.pop();
    // 注意这里要重新执行一下构造函数
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    // 没有的话，就new一个新的
    return new Klass(copyFieldsFrom);
  }
};

// release实现
var standardReleaser = function(instance) {
  var Klass = this;
  invariant(
    instance instanceof Klass,
    'Trying to release an instance into a pool of a different type.',
  );
  // 释放前执行destructor方法
  instance.destructor();  
  if (Klass.instancePool.length < Klass.poolSize) {
    // 返回对象池复用
    Klass.instancePool.push(instance);  
  }
};
```

#### 使用对象池

```javascript
// 要被池化的class
class Poolable {
  constructor(xxx) {
    this.xxx = xxx;
  }
  
  destructor() {
    this.xxx = null;
  }
}
// 池化
PoolClass.addPoolingTo(Poolable)
// 实例化对象，这里不用自己new，而是向对象池申请：
const instance = Poolable.getPooled();
// 使用instance
// 省略
// 使用完成，释放归还实例给对象池
Poolable.release(instance);
```

#### 作用

1. 对象的创建和销毁比较消耗性能，使用对象池可以尽可能降低性能损耗。
2. 对于大量频繁的创建对象操作，使用对象池可以有效减少GC的压力，避免每次GC耗时加剧影响到应用的性能。

### 事件绑定

- 根据React的事件名称寻找对应的原生事件，例如onMouseEnter事件依赖了mouseout和mouseover两个原生事件，onClick只依赖了click一个原生事件，最终会循环这些依赖，在root上绑定对应的事件
  - 依据组件中写的事件名识别其属于哪个阶段的事件（冒泡或捕获），例如onClickCapture这样的React事件名称就代表是需要事件在捕获阶段触发，而onClick代表事件需要在冒泡阶段触发。
- 调用addEventListener，将事件绑定到root元素上。
- 若事件需要更新，那么先移除事件监听，再重新绑定，绑定过程重复以上三步。

#### 事件监听器listener

```javascript
  // 根据事件名称，创建不同优先级的事件监听器。
  let listener = createEventListenerWrapperWithPriority(
    targetContainer,
    domEventName,
    eventSystemFlags,
    listenerPriority,
  );
```

根据传入的优先级返回不同级别的事件监听包装器
总的来说，会有三种事件监听器：

- dispatchDiscreteEvent: 处理离散事件
- dispatchUserBlockingUpdate：处理用户阻塞事件
- dispatchEvent：处理连续事件

### 事件触发

listener负责以不同的优先级权重来触发真正的事件流程(事件对象的合成、将事件处理函数收集到执行路径、 事件执行)，并传递事件执行阶段标志（eventSystemFlags）。

### react18新事件系统

<https://juejin.cn/post/7156225347879436318>

#### 问题

旧的事件系统中响应事件顺序是：原生事件监听 -> 捕获阶段执行 -> 冒泡阶段执行。这是不符合预期的

#### 事件绑定

<https://juejin.cn/post/6922444987091124232>

在新的事件系统中，createRoot方法会一次性注册完全部的事件

```javascript
function createRoot (container, options) {
    // ...省略
    listenToAllSupportedEvents(rootContainerElement); 
}


function listenToAllSupportedEvents (rootContainerElement) {
    /* allNativeEvents 是一个 set 集合，保存了大多数的浏览器事件 */
    if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function (domEventName) {
            // We handle selectionchange separately because it
            // doesn't bubble and needs to be on the document.
            if (domEventName !== 'selectionchange') {
            /* nonDelegatedEvents 保存了 js 中，不冒泡的事件 */
            if (!nonDelegatedEvents.has(domEventName)) {
                /* 在冒泡阶段绑定事件 */
                listenToNativeEvent(domEventName, false, rootContainerElement);
            }
            /* 在捕获阶段绑定事件 */
            listenToNativeEvent(domEventName, true, rootContainerElement);
            }
        });
    }
}
```

allNativeEvents保存了大多数的浏览器事件：包括click、keydown等81种

nonDelegatedEvents中保存了在js中不冒泡的事件：包括scroll、load、play等

如果是不冒泡的事件，只对该事件进行捕获阶段的绑定；否则会对该事件冒泡和捕获阶段都绑定

#### 事件触发

```javascript
function dispatchEventsForPlugins (domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
  /* 找到发生事件的元素——事件源 */
  var nativeEventTarget = getEventTarget(nativeEvent);
  /* 待更新队列 */
  var dispatchQueue = [];
  /* 找到待执行的事件 */
  extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
  /* 执行事件 */
  processDispatchQueue(dispatchQueue, eventSystemFlags);
}

```

## React Component

### Pure Component

pureComponent通过prop和state的浅比较（shallowEqual）来实现shouldComponentUpdate, component是需要开发者在shouldComponentUpdate钩子函数中自己写render逻辑的，在某些情况下可以使用pureComponent来提升性能。

### 有状态组件和无状态组件

#### Stateful

- 类组件
- 容器组件

#### Stateless

- 函数组件
- 展示组件

## setState

直接总结

- setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。
- setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
- setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。
