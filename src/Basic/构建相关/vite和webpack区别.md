## vite和webpack区别

1. webpack服务器启动速度比vite慢

由于vite启动的时候不需要打包，也就无需分析模块依赖、编译，所以启动速度非常快。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显

2. vite热更新比webpack快

vite在HMR方面，当某个模块内容改变时，让浏览器去重新请求该模块即可，而不是像webpack重新将该模块的所有依赖重新编译；

Vite：对于项目中的第三方依赖，仅在初次启动和依赖变化时重构建，会执行一个依赖预构建的过程。由于是基于 esBuild 做的构建，所以非常快。
对于项目代码，则会依赖于浏览器的 ESM 的支持，直接按需访问，不必全量构建。

3. vite使用esbuild(Go 编写) 预构建依赖，而webpack基于nodejs, 比node快 10-100 倍

4. vite生态不及webpack，加载器、插件不够丰富

## 为什么 webpack 构建产物看着很丑？
我们在使用 webpack 构建项目后，会发现打包出来的代码非常的“丑”，这是为什么？原因就是：webpack 支持多种模块规范，但是最后都会变成commonJS规范（webpack5 对纯 esm 做了一定的优化），但是浏览器不支持commonJS规范，于是 webpack 自己实现了require和module.exports，所以会有很多 polyfill 代码的注入。


## webpack 按需加载的模块怎么在浏览器中运行？
在实际项目开发中，随着代码越写越多，构建后的 bundle 文件也会越来越大，我们往往按照种种策略对代码进行按需加载，将某部分代码在用户事件触发后再进行加载，那么 webpack 在运行时是怎么实现的呢？

其实原理很简单，就是以 JSONP 的方式加载按需的脚本

## 白话版 webpack 构建流程
1. 初始化参数
2. 开始编译 - 初始化Compiler对象，加载插件，执行编译对象的run方法开始编译
3. 编译模块 - 从入口文件出发，调用Loader对模块进行编译，对于当前模块依赖的模块，递归执行此步骤
4. 完成编译 - 完成各个模块的依赖收集，得到了每个模块的内容和依赖关系
5. 输出资源 - 根据配置入口点、代码分割、按需加载等等策略，组装成多个chunk，将多个chunk转化成输出内容后放入资源列表
6. 写入文件系统 - 确定好输出的文件名，根据输出配置，写入指定的文件系统

## 为什么 Rollup 构建产物很干净？
- rollup 只对 ESM 模块进行打包，对于 cjs 模块也会通过插件将其转化为 ESM 模块进行打包。所以不会像 webpack 有很多的代码注入。
- rollup 对打包结果也支持多种 format 的输出，比如：esm、cjs、am 等等，但是 rollup 并不保证代码可靠运行，需要运行环境可靠支持。比如我们输出 esm 规范代码，代码运行时完全依赖高版本浏览器原生去支持 esm，rollup 不会像 webpack 一样注入一系列兼容代码。
- rollup 实现了强大的 tree-shaking 能力。


## 为什么 Vite 可以让代码直接运行在浏览器上？
当用户访问 vite 提供的开发服务器时，对于浏览器不能直接识别的文件，服务器的一些中间件会将此类文件转换成浏览器认识的文件，从而保证正常访问。
vite 会对第三方依赖进行依赖预构建生成缓存文件。